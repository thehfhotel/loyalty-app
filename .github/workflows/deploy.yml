name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

env:
  DEPLOY_PATH: /home/nut/loyalty-app  # Path on your server

jobs:
  deploy:
    runs-on: self-hosted  # Will run on your server
    environment: production  # Use production environment for secrets
    
    steps:
      - name: Clean workspace and checkout code
        run: |
          echo "üîß Preparing deployment workspace..."
          
          # Get workspace path
          WORKSPACE_DIR="${GITHUB_WORKSPACE:-$PWD}"
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          
          # Validate deployment path (no tilde paths in production)
          if [[ "$DEPLOY_DIR" == ~* ]]; then
            echo "‚ùå Error: Tilde paths not allowed in production deployment"
            echo "Current DEPLOY_DIR: $DEPLOY_DIR"
            echo "Use absolute paths like /home/nut/loyalty-app instead"
            exit 1
          fi
          
          echo "Workspace: $WORKSPACE_DIR"
          echo "Deploy Path: $DEPLOY_DIR"
          echo "Repository: ${{ github.repository }}"
          echo "Commit: ${{ github.sha }}"
          
          # Stop containers first
          echo "Stopping existing containers..."
          cd "$DEPLOY_DIR" 2>/dev/null || true
          docker compose down --remove-orphans 2>/dev/null || true
          docker compose -f docker-compose.yml -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
          
          # Clean and prepare deployment directory
          echo "Preparing deployment directory..."
          sudo rm -rf "$DEPLOY_DIR" 2>/dev/null || true
          mkdir -p "$DEPLOY_DIR"
          
          # Clone fresh code to deployment directory
          echo "Cloning repository..."
          git clone --depth 1 --branch main --single-branch \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git \
            "$DEPLOY_DIR"
          
          # Navigate to deployment directory
          cd "$DEPLOY_DIR"
          
          # Checkout specific commit
          git fetch origin ${{ github.sha }}
          git checkout ${{ github.sha }}
          
          # Verify deployment
          echo "Verifying deployment files..."
          if [ ! -f "docker-compose.yml" ] || [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå Critical deployment files missing"
            ls -la
            exit 1
          fi
          
          echo "‚úÖ Code checkout completed successfully"
          echo "Current directory: $(pwd)"
          echo "Files in deployment directory:"
          ls -la

      - name: Workspace validation and setup
        run: |
          echo "üîç Post-checkout validation..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Verify critical files exist
          if [ ! -f "docker-compose.yml" ] || [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå Critical deployment files missing"
            exit 1
          fi
          
          # Create necessary directories with proper permissions
          mkdir -p backups logs 2>/dev/null || true
          sudo chmod 755 backups logs 2>/dev/null || true
          
          # Ensure proper ownership and permissions
          sudo chown -R $(whoami):$(whoami) . 2>/dev/null || true
          
          # Test write permissions
          if ! touch test-write-permission 2>/dev/null; then
            echo "‚ùå Cannot write to deployment directory"
            exit 1
          else
            rm -f test-write-permission
          fi
          
          echo "‚úÖ Deployment validation completed"
          echo "Working in: $(pwd)"
          
      - name: Validate and set production environment variables
        run: |
          echo "üîß Setting up production environment..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Validate critical secrets exist
          missing_secrets=()
          
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then missing_secrets+=("JWT_SECRET"); fi
          if [ -z "${{ secrets.GOOGLE_CLIENT_ID }}" ]; then missing_secrets+=("GOOGLE_CLIENT_ID"); fi
          if [ -z "${{ secrets.FRONTEND_URL }}" ]; then missing_secrets+=("FRONTEND_URL"); fi
          if [ -z "${{ secrets.BACKEND_URL }}" ]; then missing_secrets+=("BACKEND_URL"); fi
          if [ -z "${{ secrets.VITE_API_URL }}" ]; then missing_secrets+=("VITE_API_URL"); fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Missing critical secrets: ${missing_secrets[*]}"
            echo "Please configure these secrets in GitHub repository settings > Environments > production"
            exit 1
          fi
          
          # Export all environment variables
          echo "NODE_ENV=production" >> $GITHUB_ENV
          echo "LOG_LEVEL=info" >> $GITHUB_ENV
          echo "CORS_ORIGINS=https://loyalty.saichon.com" >> $GITHUB_ENV
          
          # Security secrets
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> $GITHUB_ENV
          echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> $GITHUB_ENV
          echo "SESSION_SECRET=${{ secrets.SESSION_SECRET }}" >> $GITHUB_ENV
          
          # Database
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> $GITHUB_ENV
          
          # URLs (fallback to variables if secrets don't exist yet)
          echo "FRONTEND_URL=${{ secrets.FRONTEND_URL || vars.FRONTEND_URL }}" >> $GITHUB_ENV
          echo "BACKEND_URL=${{ secrets.BACKEND_URL || vars.BACKEND_URL }}" >> $GITHUB_ENV
          echo "VITE_API_URL=${{ secrets.VITE_API_URL || vars.BACKEND_URL }}" >> $GITHUB_ENV
          
          # OAuth
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> $GITHUB_ENV
          echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" >> $GITHUB_ENV
          echo "GOOGLE_CALLBACK_URL=${{ secrets.GOOGLE_CALLBACK_URL || vars.GOOGLE_CALLBACK_URL }}" >> $GITHUB_ENV
          echo "FACEBOOK_APP_ID=${{ secrets.FACEBOOK_APP_ID }}" >> $GITHUB_ENV
          echo "FACEBOOK_APP_SECRET=${{ secrets.FACEBOOK_APP_SECRET }}" >> $GITHUB_ENV
          echo "FACEBOOK_CALLBACK_URL=${{ secrets.FACEBOOK_CALLBACK_URL }}" >> $GITHUB_ENV
          echo "LINE_CHANNEL_ID=${{ secrets.LINE_CHANNEL_ID }}" >> $GITHUB_ENV
          echo "LINE_CHANNEL_SECRET=${{ secrets.LINE_CHANNEL_SECRET }}" >> $GITHUB_ENV
          echo "LINE_CALLBACK_URL=${{ secrets.LINE_CALLBACK_URL || vars.LINE_CALLBACK_URL }}" >> $GITHUB_ENV
          
          # Azure Translation
          echo "AZURE_TRANSLATION_TEXT_URI=${{ secrets.AZURE_TRANSLATION_TEXT_URI }}" >> $GITHUB_ENV
          echo "AZURE_TRANSLATION_KEY_1=${{ secrets.AZURE_TRANSLATION_KEY_1 }}" >> $GITHUB_ENV
          echo "AZURE_TRANSLATION_KEY_2=${{ secrets.AZURE_TRANSLATION_KEY_2 }}" >> $GITHUB_ENV
          echo "AZURE_TRANSLATION_REGION=${{ secrets.AZURE_TRANSLATION_REGION }}" >> $GITHUB_ENV
          
          # Admin credentials
          echo "LOYALTY_USERNAME=${{ secrets.LOYALTY_USERNAME }}" >> $GITHUB_ENV
          echo "LOYALTY_PASSWORD=${{ secrets.LOYALTY_PASSWORD }}" >> $GITHUB_ENV
          
          echo "‚úÖ Environment variables configured"

      - name: Stop existing containers with graceful shutdown
        run: |
          echo "üõë Gracefully stopping existing containers..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Check if containers are running
          if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps -q | head -1 | grep -q .; then
            echo "Containers found, initiating shutdown..."
            
            # Graceful shutdown with timeout
            timeout 30s docker compose -f docker-compose.yml -f docker-compose.prod.yml down --timeout 10 || {
              echo "‚ö†Ô∏è Graceful shutdown timed out, forcing stop..."
              docker compose -f docker-compose.yml -f docker-compose.prod.yml down --timeout 5 || true
            }
          else
            echo "No containers running"
          fi
          
          # Clean up any orphaned containers
          docker compose down --remove-orphans 2>/dev/null || true
          
          sleep 3
          echo "‚úÖ Container shutdown completed"

      - name: Create database backup with validation
        run: |
          echo "üíæ Creating database backup..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Create backups directory if it doesn't exist
          mkdir -p backups
          
          # Only backup if database container exists and is accessible
          if docker ps --format "table {{.Names}}" | grep -q postgres; then
            timestamp=$(date +%Y%m%d_%H%M%S)
            backup_file="backups/backup_${timestamp}.sql"
            
            echo "Creating backup: $backup_file"
            if docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres pg_dump -U loyalty -d loyalty_db > "$backup_file" 2>/dev/null; then
              # Validate backup file size
              if [ -s "$backup_file" ]; then
                echo "‚úÖ Database backup created successfully ($(du -h "$backup_file" | cut -f1))"
              else
                echo "‚ö†Ô∏è Backup file is empty, removing it"
                rm -f "$backup_file"
              fi
            else
              echo "‚ö†Ô∏è Database backup failed - proceeding without backup"
              rm -f "$backup_file" 2>/dev/null || true
            fi
            
            # Cleanup old backups (keep last 7)
            ls -t backups/backup_*.sql 2>/dev/null | tail -n +8 | xargs rm -f 2>/dev/null || true
          else
            echo "‚ÑπÔ∏è No database container found - skipping backup"
          fi

      - name: Pull and build containers with error handling
        run: |
          echo "üî® Building containers..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Validate docker-compose files exist
          if [ ! -f "docker-compose.yml" ]; then
            echo "‚ùå docker-compose.yml not found"
            exit 1
          fi
          
          if [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå docker-compose.prod.yml not found"
            exit 1
          fi
          
          # Validate docker-compose configuration
          echo "Validating Docker Compose configuration..."
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml config > /dev/null; then
            echo "‚ùå Docker Compose configuration is invalid"
            exit 1
          fi
          
          echo "Pulling latest images..."
          docker compose -f docker-compose.yml -f docker-compose.prod.yml pull || {
            echo "‚ö†Ô∏è Some images failed to pull, continuing with build..."
          }
          
          echo "Building containers..."
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml build --no-cache; then
            echo "‚ùå Container build failed"
            # Show build logs for debugging
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs
            exit 1
          fi
          
          echo "‚úÖ Container build completed successfully"

      - name: Start containers with health monitoring
        run: |
          echo "üöÄ Starting containers..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Start containers in detached mode
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d; then
            echo "‚ùå Failed to start containers"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs
            exit 1
          fi
          
          echo "Waiting for containers to initialize..."
          sleep 10
          
          # Monitor container health
          echo "Checking container status..."
          max_wait=60
          waited=0
          
          while [ $waited -lt $max_wait ]; do
            # Check if all containers are running
            if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps --format="table {{.Name}}\t{{.State}}" | grep -v "running" | grep -q "exited\|dead\|restarting"; then
              echo "‚ö†Ô∏è Some containers are not running properly:"
              docker compose -f docker-compose.yml -f docker-compose.prod.yml ps
              sleep 5
              waited=$((waited + 5))
            else
              echo "‚úÖ All containers are running"
              break
            fi
          done
          
          if [ $waited -ge $max_wait ]; then
            echo "‚ùå Containers failed to start properly within ${max_wait}s"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=50
            exit 1
          fi

      - name: Run database migrations
        run: |
          echo "üìä Running database migrations..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Check if consolidated schema needs to be applied
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres psql -U loyalty -d loyalty_db -c "SELECT 1 FROM users LIMIT 1" &>/dev/null; then
            echo "Applying consolidated schema..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres psql -U loyalty -d loyalty_db -f /docker-entrypoint-initdb.d/consolidated_schema.sql
          fi
          
          # Apply any new migrations
          for migration in database/migrations/*.sql; do
            if [ -f "$migration" ]; then
              echo "Applying migration: $(basename $migration)"
              docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres psql -U loyalty -d loyalty_db -f "/docker-entrypoint-initdb.d/migrations/$(basename $migration)" 2>/dev/null || true
            fi
          done

      - name: Comprehensive health check and validation
        run: |
          echo "üè• Running comprehensive health checks..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Function to check service health
          check_service_health() {
            local service=$1
            local url=$2
            local max_attempts=30
            local attempt=0
            
            echo "Checking $service health at $url"
            
            while [ $attempt -lt $max_attempts ]; do
              if curl -f -s --max-time 5 "$url" > /dev/null 2>&1; then
                echo "‚úÖ $service is healthy!"
                return 0
              fi
              
              attempt=$((attempt + 1))
              echo "Waiting for $service... (attempt $attempt/$max_attempts)"
              sleep 3
            done
            
            echo "‚ùå $service health check failed!"
            return 1
          }
          
          # Check application health
          failed_services=()
          
          # Check main application
          if ! check_service_health "Application" "http://localhost:4001/api/health"; then
            failed_services+=("Application")
          fi
          
          # Check if frontend is accessible
          if ! check_service_health "Frontend" "http://localhost:4001/"; then
            failed_services+=("Frontend")
          fi
          
          # If health checks failed, show diagnostic information
          if [ ${#failed_services[@]} -ne 0 ]; then
            echo "‚ùå Health checks failed for: ${failed_services[*]}"
            echo "\nüìä Diagnostic Information:"
            
            echo "\nüê≥ Container Status:"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml ps
            
            echo "\nüìã Backend Logs (last 30 lines):"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=30 backend || true
            
            echo "\nüìã Nginx Logs (last 20 lines):"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=20 nginx || true
            
            echo "\nüîç Port Status:"
            netstat -tlnp | grep :4001 || echo "Port 4001 not listening"
            
            exit 1
          fi
          
          echo "‚úÖ All health checks passed successfully!"

      - name: Post-deployment cleanup and optimization
        run: |
          echo "üßπ Post-deployment cleanup..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Clean up unused Docker resources
          echo "Cleaning Docker images..."
          docker image prune -f || true
          
          echo "Cleaning unused volumes (keeping data volumes)..."
          # Only clean volumes that are not in use
          docker volume prune -f || true
          
          echo "Cleaning build cache..."
          docker builder prune -f || true
          
          echo "Cleaning networks..."
          docker network prune -f || true
          
          # Show disk usage
          echo "\nüíæ Disk usage after cleanup:"
          df -h . | head -2
          
          echo "‚úÖ Cleanup completed"
          
      - name: Deployment summary and monitoring setup
        if: always()
        run: |
          echo "=============================="
          echo "üìã Deployment Status Report"
          echo "=============================="
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Commit Message: ${{ github.event.head_commit.message }}"
          echo "Actor: ${{ github.actor }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -Iseconds)"
          echo "=============================="
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          echo "\nüê≥ Container Status:"
          if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps 2>/dev/null; then
            echo "\nüìä Resource Usage:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" || true
          else
            echo "‚ùå Could not retrieve container status"
          fi
          
          echo "\nüåê Service Endpoints:"
          echo "Main Application: https://loyalty.saichon.com"
          echo "Health Check: https://loyalty.saichon.com/api/health"
          echo "Admin Panel: https://loyalty.saichon.com/admin"
          
          # Test final connectivity
          echo "\nüîç Final Connectivity Test:"
          if curl -f -s --max-time 10 "http://localhost:4001/api/health" > /dev/null; then
            echo "‚úÖ Application is responding"
          else
            echo "‚ùå Application is not responding"
          fi
          
          echo "\n‚úÖ Deployment completed at $(date)"
          echo "=============================="