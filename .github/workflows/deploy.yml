name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

env:
  DEPLOY_PATH: /home/nut/loyalty-app  # Path on your server

jobs:
  deploy:
    runs-on: self-hosted  # Will run on your server
    environment: production  # Use production environment for secrets
    
    steps:
      - name: Clean workspace and checkout code
        run: |
          echo "üîß Preparing deployment workspace..."
          
          # Get workspace path
          WORKSPACE_DIR="${GITHUB_WORKSPACE:-$PWD}"
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          
          # Validate deployment path (no tilde paths in production)
          if [[ "$DEPLOY_DIR" == ~* ]]; then
            echo "‚ùå Error: Tilde paths not allowed in production deployment"
            echo "Current DEPLOY_DIR: $DEPLOY_DIR"
            echo "Use absolute paths like /home/nut/loyalty-app instead"
            exit 1
          fi
          
          echo "Workspace: $WORKSPACE_DIR"
          echo "Deploy Path: $DEPLOY_DIR"
          echo "Repository: ${{ github.repository }}"
          echo "Commit: ${{ github.sha }}"
          
          # Stop containers first
          echo "Stopping existing containers..."
          if [ -d "$DEPLOY_DIR" ]; then
            cd "$DEPLOY_DIR"
            docker compose down --remove-orphans 2>/dev/null || true
            docker compose -f docker-compose.yml -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
          fi
          
          # Smart deployment: pull if git repo exists, clone if not
          if [ -d "$DEPLOY_DIR/.git" ]; then
            echo "üì• Updating existing repository..."
            cd "$DEPLOY_DIR"
            
            # Clean any local changes and reset to main
            git clean -fd 2>/dev/null || true
            git reset --hard HEAD 2>/dev/null || true
            git checkout main 2>/dev/null || git checkout -b main 2>/dev/null || true
            
            # Update remote and pull latest changes
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git fetch --depth 1 origin main
            git reset --hard origin/main
            
            # Checkout specific commit
            git fetch origin ${{ github.sha }} --depth 1
            git checkout ${{ github.sha }}
            
            echo "‚úÖ Repository updated successfully"
          else
            echo "üì¶ Cloning repository (first deployment)..."
            
            # Ensure parent directory exists
            mkdir -p "$(dirname "$DEPLOY_DIR")"
            
            # Remove any non-git content if directory exists but isn't a git repo
            if [ -d "$DEPLOY_DIR" ]; then
              echo "Cleaning non-git directory..."
              rm -rf "$DEPLOY_DIR"/* 2>/dev/null || true
              rm -rf "$DEPLOY_DIR"/.* 2>/dev/null || true
            fi
            
            # Clone fresh repository
            git clone --depth 1 --branch main --single-branch \
              https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git \
              "$DEPLOY_DIR"
            
            cd "$DEPLOY_DIR"
            
            # Checkout specific commit
            git fetch origin ${{ github.sha }} --depth 1
            git checkout ${{ github.sha }}
            
            echo "‚úÖ Repository cloned successfully"
          fi
          
          # Verify deployment
          echo "Verifying deployment files..."
          if [ ! -f "docker-compose.yml" ] || [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå Critical deployment files missing"
            ls -la
            exit 1
          fi
          
          echo "‚úÖ Code checkout completed successfully"
          echo "Current directory: $(pwd)"
          echo "Files in deployment directory:"
          ls -la

      - name: Workspace validation and setup
        run: |
          echo "üîç Post-checkout validation..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Verify critical files exist
          if [ ! -f "docker-compose.yml" ] || [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå Critical deployment files missing"
            exit 1
          fi
          
          # Configure sudo authentication for workspace setup
          echo "Configuring secure sudo access..."
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S echo "Sudo access configured" || {
            echo "‚ùå Failed to authenticate with sudo"
            exit 1
          }
          
          # Create necessary directories with proper permissions
          mkdir -p backups logs 2>/dev/null || true
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S chmod 755 backups logs 2>/dev/null || true
          
          # Ensure proper ownership and permissions
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S chown -R $(whoami):$(whoami) . 2>/dev/null || true
          
          # Test write permissions
          if ! touch test-write-permission 2>/dev/null; then
            echo "‚ùå Cannot write to deployment directory"
            exit 1
          else
            rm -f test-write-permission
          fi
          
          echo "‚úÖ Deployment validation completed"
          echo "Working in: $(pwd)"
          
      - name: Validate and set production environment variables
        run: |
          echo "üîß Setting up production environment..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Validate critical secrets exist
          missing_secrets=()
          
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then missing_secrets+=("JWT_SECRET"); fi
          if [ -z "${{ secrets.GOOGLE_CLIENT_ID }}" ]; then missing_secrets+=("GOOGLE_CLIENT_ID"); fi
          if [ -z "${{ secrets.FRONTEND_URL }}" ]; then missing_secrets+=("FRONTEND_URL"); fi
          if [ -z "${{ secrets.BACKEND_URL }}" ]; then missing_secrets+=("BACKEND_URL"); fi
          if [ -z "${{ secrets.VITE_API_URL }}" ]; then missing_secrets+=("VITE_API_URL"); fi
          if [ -z "${{ secrets.SUDO_PASSWORD }}" ]; then missing_secrets+=("SUDO_PASSWORD"); fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Missing critical secrets: ${missing_secrets[*]}"
            echo "Please configure these secrets in GitHub repository settings > Environments > production"
            exit 1
          fi
          
          # Export all environment variables
          echo "NODE_ENV=production" >> $GITHUB_ENV
          echo "LOG_LEVEL=info" >> $GITHUB_ENV
          echo "CORS_ORIGINS=https://loyalty.saichon.com" >> $GITHUB_ENV
          
          # Security secrets
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> $GITHUB_ENV
          echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> $GITHUB_ENV
          echo "SESSION_SECRET=${{ secrets.SESSION_SECRET }}" >> $GITHUB_ENV
          
          # Database
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> $GITHUB_ENV
          
          # URLs (fallback to variables if secrets don't exist yet)
          echo "FRONTEND_URL=${{ secrets.FRONTEND_URL || vars.FRONTEND_URL }}" >> $GITHUB_ENV
          echo "BACKEND_URL=${{ secrets.BACKEND_URL || vars.BACKEND_URL }}" >> $GITHUB_ENV
          echo "VITE_API_URL=${{ secrets.VITE_API_URL || vars.BACKEND_URL }}" >> $GITHUB_ENV
          
          # OAuth
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> $GITHUB_ENV
          echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" >> $GITHUB_ENV
          echo "GOOGLE_CALLBACK_URL=${{ secrets.GOOGLE_CALLBACK_URL || vars.GOOGLE_CALLBACK_URL }}" >> $GITHUB_ENV
          echo "FACEBOOK_APP_ID=${{ secrets.FACEBOOK_APP_ID }}" >> $GITHUB_ENV
          echo "FACEBOOK_APP_SECRET=${{ secrets.FACEBOOK_APP_SECRET }}" >> $GITHUB_ENV
          echo "FACEBOOK_CALLBACK_URL=${{ secrets.FACEBOOK_CALLBACK_URL }}" >> $GITHUB_ENV
          echo "LINE_CHANNEL_ID=${{ secrets.LINE_CHANNEL_ID }}" >> $GITHUB_ENV
          echo "LINE_CHANNEL_SECRET=${{ secrets.LINE_CHANNEL_SECRET }}" >> $GITHUB_ENV
          echo "LINE_CALLBACK_URL=${{ secrets.LINE_CALLBACK_URL || vars.LINE_CALLBACK_URL }}" >> $GITHUB_ENV
          
          # Azure Translation
          echo "AZURE_TRANSLATION_TEXT_URI=${{ secrets.AZURE_TRANSLATION_TEXT_URI }}" >> $GITHUB_ENV
          echo "AZURE_TRANSLATION_KEY_1=${{ secrets.AZURE_TRANSLATION_KEY_1 }}" >> $GITHUB_ENV
          echo "AZURE_TRANSLATION_KEY_2=${{ secrets.AZURE_TRANSLATION_KEY_2 }}" >> $GITHUB_ENV
          echo "AZURE_TRANSLATION_REGION=${{ secrets.AZURE_TRANSLATION_REGION }}" >> $GITHUB_ENV
          
          # Admin credentials
          echo "LOYALTY_USERNAME=${{ secrets.LOYALTY_USERNAME }}" >> $GITHUB_ENV
          echo "LOYALTY_PASSWORD=${{ secrets.LOYALTY_PASSWORD }}" >> $GITHUB_ENV
          
          echo "‚úÖ Environment variables configured"

      - name: Stop existing containers with graceful shutdown
        run: |
          echo "üõë Gracefully stopping existing containers..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Check if containers are running
          if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps -q | head -1 | grep -q .; then
            echo "Containers found, initiating shutdown..."
            
            # Graceful shutdown with timeout
            timeout 30s docker compose -f docker-compose.yml -f docker-compose.prod.yml down --timeout 10 || {
              echo "‚ö†Ô∏è Graceful shutdown timed out, forcing stop..."
              docker compose -f docker-compose.yml -f docker-compose.prod.yml down --timeout 5 || true
            }
          else
            echo "No containers running"
          fi
          
          # Clean up any orphaned containers
          docker compose down --remove-orphans 2>/dev/null || true
          
          sleep 3
          echo "‚úÖ Container shutdown completed"

      - name: Create database backup with validation
        run: |
          echo "üíæ Creating database backup..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Create backups directory if it doesn't exist
          mkdir -p backups
          
          # Only backup if database container exists and is accessible
          if docker ps --format "table {{.Names}}" | grep -q postgres; then
            timestamp=$(date +%Y%m%d_%H%M%S)
            backup_file="backups/backup_${timestamp}.sql"
            
            echo "Creating backup: $backup_file"
            if docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres pg_dump -U loyalty -d loyalty_db > "$backup_file" 2>/dev/null; then
              # Validate backup file size
              if [ -s "$backup_file" ]; then
                echo "‚úÖ Database backup created successfully ($(du -h "$backup_file" | cut -f1))"
              else
                echo "‚ö†Ô∏è Backup file is empty, removing it"
                rm -f "$backup_file"
              fi
            else
              echo "‚ö†Ô∏è Database backup failed - proceeding without backup"
              rm -f "$backup_file" 2>/dev/null || true
            fi
            
            # Cleanup old backups (keep last 7)
            ls -t backups/backup_*.sql 2>/dev/null | tail -n +8 | xargs rm -f 2>/dev/null || true
          else
            echo "‚ÑπÔ∏è No database container found - skipping backup"
          fi

      - name: Setup Node.js dependencies for frontend
        run: |
          echo "üì¶ Setting up frontend dependencies..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR/frontend"
          
          # Configure sudo authentication
          echo "Configuring secure sudo access..."
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S echo "Sudo access configured" || {
            echo "‚ùå Failed to authenticate with sudo"
            exit 1
          }
          
          # Fix permissions for Node.js installation
          echo "Setting proper permissions for Node.js..."
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S chown -R $(whoami):$(whoami) .
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S chmod -R 755 .
          
          # Clean any existing node_modules to avoid permission conflicts
          if [ -d "node_modules" ]; then
            echo "Cleaning existing node_modules..."
            echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S rm -rf node_modules
          fi
          
          # Smart NPM installation - use ci if lockfile exists, install if not
          echo "Installing frontend dependencies..."
          if [ -f "package-lock.json" ]; then
            echo "Using npm ci (lockfile found)..."
            npm ci
          else
            echo "Using npm install (no lockfile found)..."
            npm install
          fi
          
          echo "‚úÖ Frontend dependencies installed successfully"

      - name: Pull and build containers with error handling
        run: |
          echo "üî® Building containers..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Validate docker-compose files exist
          if [ ! -f "docker-compose.yml" ]; then
            echo "‚ùå docker-compose.yml not found"
            exit 1
          fi
          
          if [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå docker-compose.prod.yml not found"
            exit 1
          fi
          
          # Validate docker-compose configuration
          echo "Validating Docker Compose configuration..."
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml config > /dev/null; then
            echo "‚ùå Docker Compose configuration is invalid"
            exit 1
          fi
          
          # Clean up old containers and images to free space
          echo "Cleaning up old containers and images..."
          docker system prune -f || true
          
          echo "Pulling latest images..."
          docker compose -f docker-compose.yml -f docker-compose.prod.yml pull || {
            echo "‚ö†Ô∏è Some images failed to pull, continuing with build..."
          }
          
          echo "Building containers..."
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml build --no-cache; then
            echo "‚ùå Container build failed"
            # Show build logs for debugging
            echo "üìã Build logs:"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=100
            
            # Show disk space
            echo "üíæ Disk space:"
            df -h
            
            # Show system resources
            echo "üñ•Ô∏è System resources:"
            free -h
            
            exit 1
          fi
          
          echo "‚úÖ Container build completed successfully"

      - name: Start containers with health monitoring
        run: |
          echo "üöÄ Starting containers..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Start containers in detached mode
          if ! docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d; then
            echo "‚ùå Failed to start containers"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs
            exit 1
          fi
          
          echo "Waiting for containers to initialize..."
          sleep 10
          
          # Monitor container health
          echo "Checking container status..."
          max_wait=60
          waited=0
          
          while [ $waited -lt $max_wait ]; do
            # Check if all containers are running
            if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps --format="table {{.Name}}\t{{.State}}" | grep -v "running" | grep -q "exited\|dead\|restarting"; then
              echo "‚ö†Ô∏è Some containers are not running properly:"
              docker compose -f docker-compose.yml -f docker-compose.prod.yml ps
              sleep 5
              waited=$((waited + 5))
            else
              echo "‚úÖ All containers are running"
              break
            fi
          done
          
          if [ $waited -ge $max_wait ]; then
            echo "‚ùå Containers failed to start properly within ${max_wait}s"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=50
            exit 1
          fi

      - name: Setup Node.js dependencies for backend
        run: |
          echo "üì¶ Setting up Node.js dependencies..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR/backend"
          
          # Check Node.js version
          echo "Node.js version: $(node --version)"
          echo "NPM version: $(npm --version)"
          
          # Configure sudo authentication
          echo "Configuring secure sudo access..."
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S echo "Sudo access configured" || {
            echo "‚ùå Failed to authenticate with sudo"
            exit 1
          }
          
          # Fix permissions for Node.js installation
          echo "Setting proper permissions for Node.js..."
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S chown -R $(whoami):$(whoami) .
          echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S chmod -R 755 .
          
          # Clean any existing node_modules to avoid permission conflicts
          if [ -d "node_modules" ]; then
            echo "Cleaning existing node_modules..."
            echo "${{ secrets.SUDO_PASSWORD }}" | sudo -S rm -rf node_modules
          fi
          
          # Smart NPM installation - use ci if lockfile exists, install if not
          echo "Installing backend dependencies..."
          if [ -f "package-lock.json" ]; then
            echo "Using npm ci with dev dependencies (lockfile found)..."
            npm ci --include=dev
          else
            echo "Using npm install with dev dependencies (no lockfile found)..."
            npm install --include=dev
          fi
          
          # Verify Prisma installation
          echo "Verifying Prisma CLI installation..."
          npx prisma --version
          
          echo "‚úÖ Dependencies installed successfully"

      - name: Run database migrations
        run: |
          echo "üìä Running database migrations with Prisma..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Stop containers and restart with database port exposed for migrations
          echo "Restarting containers with database access for migrations..."
          docker compose -f docker-compose.yml down --timeout 10 || true
          docker compose -f docker-compose.yml up -d
          
          # Wait for database to be ready
          echo "Waiting for database to be ready..."
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            if docker compose exec -T postgres pg_isready -U loyalty -d loyalty_db >/dev/null 2>&1; then
              echo "‚úÖ Database is ready"
              break
            fi
            attempt=$((attempt + 1))
            echo "Waiting for database... (attempt $attempt/$max_attempts)"
            sleep 3
          done
          
          if [ $attempt -ge $max_attempts ]; then
            echo "‚ùå Database failed to become ready"
            echo "Container status:"
            docker compose ps postgres
            exit 1
          fi
          
          # Wait additional time for full database initialization
          echo "Allowing additional time for database initialization..."
          sleep 10
          
          # Navigate to backend directory
          cd backend
          
          # Ensure Prisma client is generated
          echo "Generating Prisma client..."
          npm run db:generate
          
          # Set database URL for host connection (using exposed port)
          export DATABASE_URL="postgresql://loyalty:loyalty_pass@localhost:5434/loyalty_db"
          
          # Deploy Prisma migrations from host (can access localhost:5434)
          echo "Deploying Prisma migrations from host..."
          npm run db:migrate:deploy
          
          # Test database connection from host
          echo "Testing database connection from host..."
          npx tsx src/test-prisma.ts
          
          # Return to deployment directory and restart with production configuration
          cd "$DEPLOY_DIR"
          echo "Restarting containers with production configuration..."
          docker compose -f docker-compose.yml down --timeout 10
          docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
          
          # Wait for containers to restart
          echo "Waiting for containers to restart..."
          sleep 15
          
          echo "‚úÖ Database migrations completed successfully"

      - name: Comprehensive health check and validation
        run: |
          echo "üè• Running comprehensive health checks..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Function to check service health
          check_service_health() {
            local service=$1
            local url=$2
            local max_attempts=30
            local attempt=0
            
            echo "Checking $service health at $url"
            
            while [ $attempt -lt $max_attempts ]; do
              if curl -f -s --max-time 5 "$url" > /dev/null 2>&1; then
                echo "‚úÖ $service is healthy!"
                return 0
              fi
              
              attempt=$((attempt + 1))
              echo "Waiting for $service... (attempt $attempt/$max_attempts)"
              sleep 3
            done
            
            echo "‚ùå $service health check failed!"
            return 1
          }
          
          # Check application health
          failed_services=()
          
          # Check main application
          if ! check_service_health "Application" "http://localhost:4001/api/health"; then
            failed_services+=("Application")
          fi
          
          # Check if frontend is accessible
          if ! check_service_health "Frontend" "http://localhost:4001/"; then
            failed_services+=("Frontend")
          fi
          
          # If health checks failed, show diagnostic information
          if [ ${#failed_services[@]} -ne 0 ]; then
            echo "‚ùå Health checks failed for: ${failed_services[*]}"
            echo "\nüìä Diagnostic Information:"
            
            echo "\nüê≥ Container Status:"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml ps
            
            echo "\nüìã Backend Logs (last 30 lines):"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=30 backend || true
            
            echo "\nüìã Nginx Logs (last 20 lines):"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=20 nginx || true
            
            echo "\nüîç Port Status:"
            netstat -tlnp | grep :4001 || echo "Port 4001 not listening"
            
            exit 1
          fi
          
          echo "‚úÖ All health checks passed successfully!"

      - name: Post-deployment cleanup and optimization
        run: |
          echo "üßπ Post-deployment cleanup..."
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          # Clean up unused Docker resources
          echo "Cleaning Docker images..."
          docker image prune -f || true
          
          echo "Cleaning unused volumes (keeping data volumes)..."
          # Only clean volumes that are not in use
          docker volume prune -f || true
          
          echo "Cleaning build cache..."
          docker builder prune -f || true
          
          echo "Cleaning networks..."
          docker network prune -f || true
          
          # Show disk usage
          echo "\nüíæ Disk usage after cleanup:"
          df -h . | head -2
          
          echo "‚úÖ Cleanup completed"
          
      - name: Deployment summary and monitoring setup
        if: always()
        run: |
          echo "=============================="
          echo "üìã Deployment Status Report"
          echo "=============================="
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Commit Message: ${{ github.event.head_commit.message }}"
          echo "Actor: ${{ github.actor }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -Iseconds)"
          echo "=============================="
          
          # Navigate to deployment directory
          DEPLOY_DIR="${DEPLOY_PATH:-/home/nut/loyalty-app}"
          cd "$DEPLOY_DIR"
          
          echo "\nüê≥ Container Status:"
          if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps 2>/dev/null; then
            echo "\nüìä Resource Usage:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" || true
          else
            echo "‚ùå Could not retrieve container status"
          fi
          
          echo "\nüåê Service Endpoints:"
          echo "Main Application: https://loyalty.saichon.com"
          echo "Health Check: https://loyalty.saichon.com/api/health"
          echo "Admin Panel: https://loyalty.saichon.com/admin"
          
          # Test final connectivity
          echo "\nüîç Final Connectivity Test:"
          if curl -f -s --max-time 10 "http://localhost:4001/api/health" > /dev/null; then
            echo "‚úÖ Application is responding"
          else
            echo "‚ùå Application is not responding"
          fi
          
          echo "\n‚úÖ Deployment completed at $(date)"
          echo "=============================="