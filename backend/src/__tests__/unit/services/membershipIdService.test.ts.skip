/**
 * MembershipIdService Unit Tests
 * Tests membership ID generation, validation, and block-based system
 */

import { describe, it, expect, jest, beforeEach } from '@jest/globals';
import { membershipIdService } from '../../../services/membershipIdService';
import * as database from '../../../config/database';

// Mock dependencies
jest.mock('../../../config/database');
jest.mock('../../../utils/logger');

describe('MembershipIdService', () => {
  let mockQuery: jest.MockedFunction<typeof database.query>;

  beforeEach(() => {
    jest.clearAllMocks();
    mockQuery = database.query as jest.MockedFunction<typeof database.query>;
  });

  describe('Membership ID Generation', () => {
    it('should generate 8-digit membership ID starting with 269', async () => {
      const userId = 'user-1';

      // Mock the generate_membership_id function call
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900001' }
      ]);

      const membershipId = await membershipIdService.generateUniqueMembershipId(userId);

      expect(membershipId).toMatch(/^269\d{5}$/);
      expect(membershipId.length).toBe(8);
      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('SELECT generate_membership_id'),
        [userId]
      );
    });

    it('should generate sequential IDs for first 100 users', async () => {
      const userIds = ['user-1', 'user-2', 'user-3', 'user-4', 'user-5'];
      const expectedIds = ['26900001', '26900002', '26900003', '26900004', '26900005'];

      // Mock sequential ID generation
      for (let i = 0; i < userIds.length; i++) {
        mockQuery.mockResolvedValueOnce([
          { generate_membership_id: expectedIds[i] }
        ]);
      }

      const membershipIds: string[] = [];
      for (const userId of userIds) {
        const id = await membershipIdService.generateUniqueMembershipId(userId);
        membershipIds.push(id);
      }

      expect(membershipIds).toEqual(expectedIds);
    });

    it('should assign IDs in correct blocks', async () => {
      const userId = 'user-block-1';

      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900050' }
      ]);

      const id = await membershipIdService.generateUniqueMembershipId(userId);

      expect(id).toMatch(/^269000\d{2}$/); // Block 1: 26900001-26900100
    });

    it('should handle block transitions', async () => {
      // Mock block 1 last ID
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900100' }
      ]);

      const id100 = await membershipIdService.generateUniqueMembershipId('user-100');

      // Mock block 2 first ID
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900101' }
      ]);

      const id101 = await membershipIdService.generateUniqueMembershipId('user-101');

      expect(id100).toBe('26900100'); // Last in block 1
      expect(id101).toBe('26900101'); // First in block 2
    });

    it('should generate unique IDs for different users', async () => {
      mockQuery
        .mockResolvedValueOnce([{ generate_membership_id: '26900001' }])
        .mockResolvedValueOnce([{ generate_membership_id: '26900002' }]);

      const id1 = await membershipIdService.generateUniqueMembershipId('user-1');
      const id2 = await membershipIdService.generateUniqueMembershipId('user-2');

      expect(id1).not.toBe(id2);
    });

    it('should not generate duplicate IDs', async () => {
      const userIds = Array.from({ length: 10 }, (_, i) => `user-${i + 1}`);
      const uniqueIds = Array.from({ length: 10 }, (_, i) => `2690000${i + 1}`);

      // Mock unique ID generation for each user
      userIds.forEach((_, i) => {
        mockQuery.mockResolvedValueOnce([
          { generate_membership_id: uniqueIds[i] }
        ]);
      });

      const membershipIds = await Promise.all(
        userIds.map(userId => membershipIdService.generateUniqueMembershipId(userId))
      );

      const uniqueSet = new Set(membershipIds);
      expect(uniqueSet.size).toBe(membershipIds.length);
    });
  });

  describe('User Lookup by Membership ID', () => {
    it('should find user by membership ID', async () => {
      const userId = 'user-lookup-1';
      const membershipId = '26900001';

      mockQuery.mockResolvedValueOnce([
        {
          id: userId,
          email: 'lookup1@test.com',
          line_id: 'line-lookup-1',
          display_name: 'Lookup User',
          membership_id: membershipId
        }
      ]);

      const foundUser = await membershipIdService.getUserByMembershipId(membershipId);

      expect(foundUser).toBeDefined();
      expect(foundUser!.id).toBe(userId);
      expect(foundUser!.email).toBe('lookup1@test.com');
      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('SELECT'),
        [membershipId]
      );
    });

    it('should return null for nonexistent membership ID', async () => {
      mockQuery.mockResolvedValueOnce([]);

      const foundUser = await membershipIdService.getUserByMembershipId('26999999');

      expect(foundUser).toBeNull();
    });

    it('should return null for invalid membership ID format', async () => {
      mockQuery.mockResolvedValueOnce([]);

      const foundUser = await membershipIdService.getUserByMembershipId('invalid');

      expect(foundUser).toBeNull();
    });

    it('should handle leading zeros in membership ID', async () => {
      const membershipId = '26900001';

      mockQuery.mockResolvedValueOnce([
        {
          id: 'user-zeros',
          email: 'zeros@test.com',
          membership_id: membershipId
        }
      ]);

      const foundUser = await membershipIdService.getUserByMembershipId(membershipId);

      expect(foundUser).toBeDefined();
      expect(foundUser!.membership_id).toBe(membershipId);
    });
  });

  describe('Membership ID Regeneration', () => {
    it('should regenerate membership ID for user', async () => {
      const userId = 'user-regen-1';
      const oldId = '26900001';
      const newId = '26900002';

      // Mock user lookup
      mockQuery.mockResolvedValueOnce([
        { id: userId, membership_id: oldId }
      ]);

      // Mock new ID generation
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: newId }
      ]);

      const regeneratedId = await membershipIdService.regenerateMembershipId(userId);

      expect(regeneratedId).toBe(newId);
      expect(regeneratedId).not.toBe(oldId);
      expect(regeneratedId).toMatch(/^269\d{5}$/);
    });

    it('should make old ID available after regeneration', async () => {
      const userId = 'user-avail';
      const oldId = '26900001';
      const newId = '26900002';

      // Mock user with old ID
      mockQuery.mockResolvedValueOnce([
        { id: userId, membership_id: oldId }
      ]);

      // Mock regeneration
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: newId }
      ]);

      await membershipIdService.regenerateMembershipId(userId);

      // Mock lookup of old ID returns nothing
      mockQuery.mockResolvedValueOnce([]);

      const foundUser = await membershipIdService.getUserByMembershipId(oldId);
      expect(foundUser).toBeNull();
    });

    it('should handle multiple regenerations', async () => {
      const userId = 'user-multi-regen';

      // First generation
      mockQuery.mockResolvedValueOnce([
        { id: userId, membership_id: '26900001' }
      ]);
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900002' }
      ]);

      const id2 = await membershipIdService.regenerateMembershipId(userId);

      // Second regeneration
      mockQuery.mockResolvedValueOnce([
        { id: userId, membership_id: '26900002' }
      ]);
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900003' }
      ]);

      const id3 = await membershipIdService.regenerateMembershipId(userId);

      expect(id2).toBe('26900002');
      expect(id3).toBe('26900003');
      expect(id2).not.toBe(id3);
    });

    it('should fail to regenerate for nonexistent user', async () => {
      mockQuery.mockResolvedValueOnce([]);

      await expect(
        membershipIdService.regenerateMembershipId('nonexistent-user')
      ).rejects.toThrow();
    });
  });

  describe('Membership ID Statistics', () => {
    it('should return correct total count', async () => {
      mockQuery.mockResolvedValueOnce([
        {
          total_assigned: 5,
          current_block: 1,
          available_in_block: 95
        }
      ]);

      const stats = await membershipIdService.getMembershipIdStats();

      expect(stats.totalAssigned).toBe(5);
    });

    it('should return correct current block', async () => {
      mockQuery.mockResolvedValueOnce([
        {
          total_assigned: 1,
          current_block: 1,
          available_in_block: 99
        }
      ]);

      const stats = await membershipIdService.getMembershipIdStats();

      expect(stats.currentBlock).toBe(1);
    });

    it('should calculate available IDs in current block', async () => {
      mockQuery.mockResolvedValueOnce([
        {
          total_assigned: 10,
          current_block: 1,
          available_in_block: 90
        }
      ]);

      const stats = await membershipIdService.getMembershipIdStats();

      expect(stats.availableInBlock).toBe(90);
    });

    it('should return stats for empty system', async () => {
      mockQuery.mockResolvedValueOnce([
        {
          total_assigned: 0,
          current_block: 1,
          available_in_block: 100
        }
      ]);

      const stats = await membershipIdService.getMembershipIdStats();

      expect(stats.totalAssigned).toBe(0);
      expect(stats.currentBlock).toBe(1);
      expect(stats.availableInBlock).toBe(100);
    });
  });

  describe('Validation', () => {
    it('should validate correct membership ID format', () => {
      const isValid = membershipIdService.isValidMembershipId('26900001');
      expect(isValid).toBe(true);
    });

    it('should reject IDs not starting with 269', () => {
      const isValid = membershipIdService.isValidMembershipId('12345678');
      expect(isValid).toBe(false);
    });

    it('should reject IDs with incorrect length', () => {
      expect(membershipIdService.isValidMembershipId('269')).toBe(false);
      expect(membershipIdService.isValidMembershipId('269000001')).toBe(false);
    });

    it('should reject non-numeric IDs', () => {
      const isValid = membershipIdService.isValidMembershipId('269ABCDE');
      expect(isValid).toBe(false);
    });

    it('should reject empty strings', () => {
      const isValid = membershipIdService.isValidMembershipId('');
      expect(isValid).toBe(false);
    });
  });

  describe('Edge Cases', () => {
    it('should handle rapid concurrent ID generation', async () => {
      const userIds = Array.from({ length: 20 }, (_, i) => `user-concurrent-${i + 1}`);
      const uniqueIds = Array.from({ length: 20 }, (_, i) => `26900${String(i + 1).padStart(3, '0')}`);

      // Mock unique ID for each concurrent request
      userIds.forEach((_, i) => {
        mockQuery.mockResolvedValueOnce([
          { generate_membership_id: uniqueIds[i] }
        ]);
      });

      const membershipIds = await Promise.all(
        userIds.map(userId => membershipIdService.generateUniqueMembershipId(userId))
      );

      const uniqueSet = new Set(membershipIds);
      expect(uniqueSet.size).toBe(20);
    });

    it('should handle maximum attempts exceeded', async () => {
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900001' }
      ]);

      const membershipId = await membershipIdService.generateUniqueMembershipId('user-max');

      expect(membershipId).toMatch(/^269\d{5}$/);
    });

    it('should handle user without membership ID', async () => {
      mockQuery.mockResolvedValueOnce([
        {
          id: 'user-no-id',
          email: 'noid@test.com',
          membership_id: null
        }
      ]);

      const foundUser = await membershipIdService.getUserByMembershipId('26900001');

      // Since we're testing lookup, this would return null if ID doesn't exist
      expect(mockQuery).toHaveBeenCalled();
    });
  });

  describe('Performance', () => {
    it('should generate IDs quickly', async () => {
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: '26900001' }
      ]);

      const startTime = Date.now();
      await membershipIdService.generateUniqueMembershipId('user-perf');
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(1000);
    });

    it('should handle batch generation efficiently', async () => {
      const userIds = Array.from({ length: 30 }, (_, i) => `user-batch-${i + 1}`);

      userIds.forEach((_, i) => {
        mockQuery.mockResolvedValueOnce([
          { generate_membership_id: `26900${String(i + 1).padStart(3, '0')}` }
        ]);
      });

      const startTime = Date.now();
      await Promise.all(
        userIds.map(userId => membershipIdService.generateUniqueMembershipId(userId))
      );
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(5000);
    });
  });

  describe('Database Integrity', () => {
    it('should maintain unique constraint', async () => {
      const id1 = '26900001';

      // Mock first user ID generation
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: id1 }
      ]);

      await membershipIdService.generateUniqueMembershipId('user-1');

      // Mock second user trying to get same ID (should fail in DB)
      mockQuery.mockRejectedValueOnce(
        new Error('duplicate key value violates unique constraint')
      );

      await expect(
        membershipIdService.generateUniqueMembershipId('user-2')
      ).rejects.toThrow();
    });

    it('should update user record with membership ID', async () => {
      const userId = 'user-update';
      const membershipId = '26900001';

      // Mock ID generation
      mockQuery.mockResolvedValueOnce([
        { generate_membership_id: membershipId }
      ]);

      const generated = await membershipIdService.generateUniqueMembershipId(userId);

      // Mock verification query
      mockQuery.mockResolvedValueOnce([
        { membership_id: membershipId }
      ]);

      expect(generated).toBe(membershipId);
      expect(mockQuery).toHaveBeenCalled();
    });
  });
});
